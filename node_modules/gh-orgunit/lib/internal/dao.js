/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var csv = require('csv');
var moment = require('moment');
var util = require('util');

var DB = require('gh-core/lib/db');
var EventsDAO = require('gh-events/lib/internal/dao');
var GroupsDAO = require('gh-groups/lib/internal/dao');
var log = require('gh-core/lib/logger').logger('gh-orgunit');
var SeriesDAO = require('gh-series/lib/internal/dao');
var UsersDAO = require('gh-users/lib/internal/dao');

/**
 * Create an organisational unit
 *
 * @param  {Number}         appId                       The id of the application on which to create the organisational unit
 * @param  {String}         displayName                 The name of the organisational unit
 * @param  {String}         type                        The organisational unit type (e.g. `course`, `subject`, `part`, `module`)
 * @param  {Number}         groupId                     The id of the group that can manage the organisational unit
 * @param  {Object}         [opts]                      A set of optional parameters
 * @param  {String}         [opts.description]          The description of the organisational unit
 * @param  {Object}         [opts.metadata]             The extra metadata for the organisational unit as a JSON object
 * @param  {Boolean}        [opts.published]            The published flag of the organisational unit
 * @param  {String}         [opts.externalId]           The external id of the organisational unit
 * @param  {Number}         [opts.parentId]             The id of the parent organisational unit
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {OrgUnit}        callback.orgUnit            The created organisational unit
 */
var createOrgUnit = module.exports.createOrgUnit = function(appId, displayName, type, groupId, opts, callback) {
    opts = opts || {};

    var orgUnit = {
        'AppId': appId,
        'description': opts.description,
        'displayName': displayName,
        'externalId': opts.externalId,
        'metadata': opts.metadata,
        'published': opts.published,
        'GroupId': groupId,
        'ParentId': opts.parentId,
        'type': type
    };
    DB.OrgUnit.create(orgUnit).complete(function(err, orgUnit) {
        if (err) {
            log().error({'err': err}, 'Failed to create organisational unit');
            return callback({'code': 500, 'msg': 'Failed to create an organisational unit'});
        }

        return callback(null, orgUnit);
    });
};

/**
 * Update an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to update
 * @param  {Object}         opts                The values to update
 * @param  {String}         [opts.displayName]  Updated organisational unit name
 * @param  {String}         [opts.description]  Updated organisational unit description
 * @param  {String}         [opts.type]         Updated organisational unit type
 * @param  {Object}         [opts.metadata]     Updated organisational unit metadata
 * @param  {Boolean}        [opts.published]    Updated organisational unit published flag
 * @param  {Number}         [opts.GroupId]      Updated organisational unit group
 * @param  {Number}         [opts.ParentId]     Updated organisational unit parent
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {OrgUnit}        callback.orgUnit    The updated organisational unit
 */
var updateOrgUnit = module.exports.updateOrgUnit = function(orgUnit, opts, callback) {
    orgUnit.updateAttributes(opts).complete(function(err, orgUnit) {
        if (err) {
            log().error({'err': err}, 'Failed to update an organisational unit');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'orgUnit': orgUnit, 'update': opts}, 'Updated an organisational unit');
        return callback(null, orgUnit);
    });
};

/**
 * Delete an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteOrgUnit = module.exports.deleteOrgUnit = function(orgUnit, callback) {
    orgUnit.destroy().complete(function(err) {
        if (err) {
            log().error({'err': err}, 'Failed to delete an organisational unit');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'orgUnit': orgUnit}, 'Deleted an organisational unit');
        return callback();
    });
};

/**
 * Get an organisational unit
 *
 * @param  {Number}         id                  The id of the organisational unit to retrieve
 * @param  {Boolean}        [includeSeries]     Whether to include the event series associated to the organisational unit. Defaults to `false`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {OrgUnit}        callback.orgUnit    The retrieved organisational unit
 */
var getOrgUnit = module.exports.getOrgUnit = function(id, includeSeries, callback) {
    var options = {
        'where': {'id': id},
        'include': [DB.Group, DB.App]
    };
    if (includeSeries) {
        options.include.push(DB.Serie);
    }
    DB.OrgUnit.findOne(options).complete(function(err, orgUnit) {
        if (err) {
            log().error({'err': err, 'id': id, 'includeSeries': includeSeries}, 'Failed to get an organisational unit');
            return callback({'code': 500, 'msg': 'Failed to get an organisational unit'});
        } else if (!orgUnit) {
            log().debug({'err': err, 'id': id, 'includeSeries': includeSeries}, 'Could not find an organisational unit');
            return callback({'code': 404, 'msg': 'Could not find an organisational unit'});
        }

        return callback(null, orgUnit);
    });
};

/**
 * Get organisational units by id
 *
 * @param  {Number[]}   ids                     The ids of the organisational units to retrieve
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {OrgUnit[]}  callback.orgUnits       The retrieved organisational units
 */
var getOrgUnitsById = module.exports.getOrgUnitsById = function(ids, callback) {
    if (_.isEmpty(ids)) {
        return callback(null, []);
    }

    DB.OrgUnit.findAll({'where': {'id': ids}}).complete(function(err, orgUnits) {
        if (err) {
            log().error({'err': err, 'id': ids}, 'Failed to get organisational units by id');
            return callback({'code': 500, 'msg': 'Failed to get organisational units by id'});
        } else if (orgUnits.length !== ids.length) {
            log().debug({'err': err, 'id': ids}, 'Not all organisational units could be found');
            return callback({'code': 404, 'msg': 'Not all organisational units could be found'});
        }

        return callback(null, orgUnits);
    });
};

/**
 * Get organisational units by their external id
 *
 * @param  {Number}     appId                   The id of the application for which to retrieve the organisational units
 * @param  {String[]}   externalIds             The external ids of the organisational units to retrieve
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {OrgUnit[]}  callback.orgUnits       The retrieved organisational units
 */
var getOrgUnitsByExternalId = module.exports.getOrgUnitsByExternalId = function(appId, externalIds, callback) {
    if (_.isEmpty(externalIds)) {
        return callback(null, []);
    }

    var opts = {
        'where': {
            'AppId': appId,
            'externalId': externalIds
        }
    };
    DB.OrgUnit.findAll(opts).complete(function(err, orgUnits) {
        if (err) {
            log().error({'err': err, 'id': ids}, 'Failed to get organisational units by external id');
            return callback({'code': 500, 'msg': 'Failed to get organisational units by external id'});
        }

        return callback(null, orgUnits);
    });
};

/**
 * Get the organisational units for an application
 *
 * @param  {Number}         appId                           The id of the app to get the organisational units for
 * @param  {Number}         [parentId]                      The id of the parent to retrieve the organisational units for
 * @param  {String[]}       [types]                         The organisational unit type[s] to filter the organisational unit by
 * @param  {Object}         [opts]                          A set of extra options that can be specified
 * @param  {Boolean}        [opts.includeSeries]            Whether to include the event series associated to the organisational units. Defaults to `false`
 * @param  {Boolean}        [opts.includeGroups]            Whether to include the group objects associated to the organisational units. Defaults to `false`
 * @param  {Object}         [opts.subscriptions]            The subscription options
 * @param  {Boolean}        [opts.subscriptions.include]    Whether to include if the user specified by `opts.subscriptions.userId` is subscribed to each serie
 * @param  {Number}         [opts.subscriptions.userId]     The id of the user for whom the event series subscriptions need to be checked
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {OrgUnit}        callback.orgUnits               The matching organisational units
 */
var getOrgUnits = module.exports.getOrgUnits = function(appId, parentId, types, opts, callback) {
    opts = opts || {};
    opts.subscriptions = opts.subscriptions || {'include': false};

    var options = {
        'where': {'AppId': appId},
        'include': []
    };
    if (parentId) {
        options.where.ParentId = parentId;
    }
    if (!_.isEmpty(types)) {
        options.where.type = types;
    }

    // Include the event series if necessary
    if (opts.includeSeries) {
        var includeSeries = {'model': DB.Serie, 'required': false, 'include': []};

        // Include the first organisational unit (=A) the series was added to. If this organisational unit (A) doesn't
        // match up with the organisational unit (B) in the main query it means the series was borrowed from A under B
        includeSeries.include.push({
            'model': DB.OrgUnit,
            'required': false,
            'attributes': ['id', 'displayName', 'ParentId']
        });

        // Indicate whether the user is subscribed to the series
        if (opts.subscriptions.include && opts.subscriptions.userId) {
            includeSeries.include.push({
                'model': DB.Calendar,
                'where': {'UserId': opts.subscriptions.userId},
                'required': false,
                'limit': null
            });
        }

        options.include.push(includeSeries);
    }

    // Include the group object if necessary
    if (opts.includeGroups) {
        options.include.push({'model': DB.Group, 'required': true, 'include': [
            {'model': DB.User, 'required': false, 'as': 'LockedBy', 'attributes': ['id', 'displayName']}
        ]});
    }

    DB.OrgUnit.findAll(options).complete(function(err, orgUnits) {
        if (err) {
            log().error({
                'err': err,
                'appId': appId,
                'parentId': parentId,
                'types': types,
                'includeSeries': opts.includeSeries,
                'includeGroups': opts.includeGroups
            }, 'Failed to get the organisational units for an app');
            return callback({'code': 500, 'msg': 'Failed to get the organisational units for an app'});
        }

        return callback(null, orgUnits);
    });
};

/* Series */

/**
 * Get the event series for an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to retrieve the event series for
 * @param  {Number}         limit               The maximum number of results to retrieve
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Boolean}        upcoming            Whether to only include event series with upcoming events
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie[]}        callback.series     The event series for the organisational unit
 */
var getOrgUnitSeries = module.exports.getOrgUnitSeries = function(orgUnit, limit, offset, upcoming, callback) {
    // TODO: upcoming
    orgUnit.getSeries({'limit': limit, 'offset': offset}).complete(function(err, series) {
        if (err) {
            log().error({
                'err': err,
                'limit': limit,
                'offset': offset,
                'id': orgUnit.id
            }, 'Failed to get the series for an organisational unit');
            return callback({'code': 500, 'msg': 'Failed to get the series for an organisational unit'});
        }

        return callback(null, series);
    });
};

/**
 * Add an event series to an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to add the serie(s) to
 * @param  {Serie[]}        series              The serie(s) to add to the organisational unit
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var addOrgUnitSeries = module.exports.addOrgUnitSeries = function(orgUnit, series, callback) {
    orgUnit.addSeries(series).complete(function(err) {
        if (err) {
            log().error({
                'err': err,
                'id': orgUnit.id,
                'series': _.pluck(series, 'id')
            }, 'Unable to add series to an organisational unit');
            return callback({'code': 500, 'msg': 'Unable to add series to an organisational unit'});
        }

        return callback();
    });
};

/**
 * Remove an event series from an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to remove the serie(s) from
 * @param  {Serie[]}        series              The serie(s) to remove from the organisational unit
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteOrgUnitSeries = module.exports.deleteOrgUnitSeries = function(orgUnit, series, callback) {
    orgUnit.removeSeries(series).complete(function(err) {
        if (err) {
            log().error({
                'err': err,
                'id': orgUnit.id,
                'series': _.pluck(series, 'id')
            }, 'Unable to remove series from an organisational unit');
            return callback({'code': 500, 'msg': 'Unable to remove series from an organisational unit'});
        }

        return callback();
    });
};

/**
 * Subscribe a user to the event series and events in an organisational unit
 *
 * @param  {OrgUnit}    orgUnit         The organisational unit to subscribe the user to
 * @param  {User}       user            The user that needs to be subscribed to the event series and events in an organisational unit
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var subscribeOrgUnit = module.exports.subscribeOrgUnit = function(orgUnit, user, callback) {
    // TODO: Get/Add events & transaction

    // Get all the event series in the organisational unit
    getOrgUnitSeries(orgUnit, null, null, null, function(err, series) {
        if (err) {
            return callback(err);
        }

        UsersDAO.subscribeSeries(series, user, orgUnit.id, callback);
    });
};

/**
 * Unsubscribe a user from the event series and events in an organisational unit
 *
 * @param  {OrgUnit}    orgUnit         The organisational unit to unsubscribe the user from
 * @param  {User}       user            The user that needs to be unsubscribed from the event series and events in an organisational unit
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var unsubscribeOrgUnit = module.exports.unsubscribeOrgUnit = function(orgUnit, user, callback) {
    // TODO: Get/Add events & transactions

    // Get all the event series in the organisational unit
    getOrgUnitSeries(orgUnit, null, null, null, function(err, series) {
        if (err) {
            return callback(err);
        }

        UsersDAO.unsubscribeSeries(series, user, callback);
    });
};

/* Calendar */

/**
 * Get the calendar for an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to get the calendar for
 * @param  {String}         [start]             The timestamp (ISO 8601) from which to get the calendar for the organisation unit
 * @param  {String}         [end]               The timestamp (ISO 8601) until which to get the calendar for the organisation unit
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event[]}        callback.events     The requested organisational unit calendar
 */
var getOrgUnitCalendar = module.exports.getOrgUnitCalendar = function(orgUnit, start, end, callback) {
    var dateTimeFilter = {};
    if (start) {
        dateTimeFilter.start = {'gte': start};
    }
    if (end) {
        dateTimeFilter.end = {'lte': end};
    }

    // Minimise the amount of data we retrieve so Sequelize has less to deserialize
    var eventFields = ['id', 'displayName', 'start', 'end', 'location', 'type', 'notes', 'organiserOther', 'updatedAt'];
    var userFields = ['id', 'displayName'];

    var options = {
        // Adding `required` into the model inclusions forces Sequelize to use a
        // `left outer join` to connect the Serie/Events. If these were to be omitted,
        // Sequelize would use an `inner join` which would always result in 0 rows
        'include': [
            {'model': DB.Event, 'where': dateTimeFilter, 'required': false, 'attributes': eventFields, 'include': [
                {'model': DB.User, 'as': 'Organisers', 'required': false, 'attributes': userFields}
            ]}
        ]
    };
    orgUnit.getSeries(options).complete(function(err, series) {
        if (err) {
            log().error({
                'err': err,
                'id': orgUnit.id
            }, 'Unable to get the calendar for an organisational unit');
            return callback({'code': 500, 'msg': 'Unable to get the calendar for an organisational unit'});
        }

        var events = [];
        _.each(series, function(serie) {
            events = events.concat(serie.Events);
        });

        // Sort the events on their start date
        events = _.sortBy(events, 'start');

        // TODO: When implemented, add directly associated events
        return callback(null, events);
    });
};

/**
 * Export the organisational units, event series and events under an organisational unit
 *
 * @param  {OrgUnit}        orgUnit             The organisational unit to export
 * @param  {String}         format              The format in which the organisational units, event series and events should be exported. Options are `json` or `csv`
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Object|String}  callback.data       The exported organisational units, event series and events
 */
var exportOrgUnit = module.exports.exportOrgUnit = function(orgUnit, format, callback) {
    // Get all the organisational units under the given organisational unit
    _getChildOrgUnits([orgUnit.id], function(err, orgUnitIds) {
        if (err) {
            return callback(err);
        }

        // Get the event series and events under the organisational units
        var options = {
            'where': {
                'id': orgUnitIds
            },
            'include': [
                // Series that are associated to the organisational unit
                {'model': DB.Serie, 'include': [
                    {'model': DB.Event, 'include': [
                        {'model': DB.User, 'as': 'Organisers'}
                    ]},

                    // Include the organisational units the series was added to including the
                    // `createdAt` timestamp of when the relation was made. When the organisational
                    // units are sorted on this timestamp, the first org unit will be the "original"
                    // organisational unit where the series was added to and the others will be
                    // organisational units under which the series was borrowed
                    {
                        'model': DB.OrgUnit,
                        'required': false,
                        'attributes': ['id', 'displayName', 'ParentId']
                    }
                ]}

                // TODO: Events that are directly associated to the organisational unit
            ]
        };
        DB.OrgUnit.findAll(options).complete(function(err, orgUnits) {
            if (err) {
                log().error({
                    'err': err,
                    'id': orgUnit.id
                }, 'Unable to export an organisational unit');
                return callback({'code': 500, 'msg': 'Unable to export an organisational unit'});
            }

            if (format === 'csv') {
                return _exportOrgUnitCSV(orgUnit.id, orgUnits, callback);
            } else {
                return _exportOrgUnitJSON(orgUnit.id, orgUnits, callback);
            }
        });
    });
};

/**
 * Find all the organisational units under a set of organisational units. This function will
 * perform a breadth-first search through the organisational unit structure generating in an SQL
 * query per level. This means that if the maximum depth of one of the trees is 4, 4 SQL queries will be executed
 *
 * @param  {Number[]}   orgUnitIds                  The ids of the organisational units to expand
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Number[]}   callback.allOrgUnitIds      The ids of the organisational units that are part of the tree (including the original root ids)
 * @api private
 */
var _getChildOrgUnits = function(orgUnitIds, callback, _allOrgUnitIds) {
    _allOrgUnitIds = _allOrgUnitIds || orgUnitIds;

    // Get the children of the specified organisational units
    _getDirectChildOrgUnits(orgUnitIds, function(err, childOrgUnitIds) {
        if (err) {
            return callback(err);
        }

        // If a child was produced that we've already seen it means the organisational unit structure
        // is not a tree. We currently do not support such structures
        var seenChildOrgUnitIds = _.intersection(_allOrgUnitIds, childOrgUnitIds);
        if (!_.isEmpty(seenChildOrgUnitIds)) {
            log().error({'orgUnitIds': seenChildOrgUnitIds}, 'Cycle detected in tree');
            return callback({'code': 400, 'msg': 'Cycle detected in tree'});
        }

        // If no further children could be produced, we return
        if (_.isEmpty(childOrgUnitIds)) {
            return callback(null, _allOrgUnitIds);
        }

        // Add the children to the set of known organisational unit ids and get the children's children
        _allOrgUnitIds = _.union(_allOrgUnitIds, childOrgUnitIds);
        _getChildOrgUnits(childOrgUnitIds, callback, _allOrgUnitIds);
    });
};

/**
 * Get the ids of the direct children of a set of organisational units
 *
 * @param  {Number[]}   parentOrgUnitIds            The ids of the parent organisational units
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Number[]}   callback.childOrgUnitIds    The ids of the organisational units that are direct children of the given set of organisational unit ids
 * @api private
 */
var _getDirectChildOrgUnits = function(parentOrgUnitIds, callback) {
    var options = {
        'attributes': ['id'],
        'where': {
            'ParentId': parentOrgUnitIds
        }
    };
    DB.OrgUnit.findAll(options).complete(function(err, childOrgUnits) {
        if (err) {
            return callback(err);
        }

        var ids = _.pluck(childOrgUnits, 'id');
        return callback(null, ids);
    });
};

/**
 * Export the organisational units, event series and events under an organisational unit to CSV
 *
 * @param  {Number}         rootId              The id of the root organisational unit in the tree of organisational units, event series and events
 * @param  {OrgUnit[]}      orgUnits            All the organisational units that are in the tree. Each organisational unit should have the event series and events that are under it available on its object
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.data       The exported organisational units, event series and events as CSV
 * @see gh-orgunit/lib/rest.js for more information
 * @api private
 */
var _exportOrgUnitCSV = function(rootId, orgUnits, callback) {
    // Get the simplified tree by exporting it to JSON first
    _exportOrgUnitJSON(rootId, orgUnits, function(err, exportedOrgUnit) {
        if (err) {
            return callback(err);
        }

        // Transform the exported organisational unit to a flat data structure that can be stringied into CSV
        var records = _getExportCSVRecords(exportedOrgUnit);

        // Get the columns for all the records
        var columns = {};
        _.each(records, function(record) {
            _.each(record, function(val, key) {
                columns[key] = true;
            });
        });

        // Sort the columns ascending on the level they appeared on, series and events always
        // go at the back
        columns = _.keys(columns).sort(function(a, b) {
            if (a.indexOf('series_') === 0) {
                return -100;
            } else if (a.indexOf('event_') === 0) {
                return -200;
            } else {
                return a > b;
            }
        });

        // Stringify the records into CSV
        var options = {
            'header': true,
            'columns': columns
        };
        return csv.stringify(records, options, callback);
    });
};

/**
 * Get the CSV records for an organisational unit tree
 *
 * @param  {Object}         exportedOrgUnit     A tree as generated by `exportOrgUnitJSON`
 * @return {Object[]}                           A set of objects that can be stringified into CSV
 * @api private
 */
var _getExportCSVRecords = function(exportedOrgUnit) {
    // Will contain an object per line in the resulting CSV file
    var records = [];

    var visitOrgUnit = function(orgUnit, record, level) {
        var type = orgUnit.type;
        record[util.format('%d_%s_id', level, type)] = orgUnit.id;
        record[util.format('%d_%s_externalId', level, type)] = orgUnit.externalId;
        record[util.format('%d_%s_displayName', level, type)] = orgUnit.displayName;
        record[util.format('%d_%s_description', level, type)] = orgUnit.description;
        record[util.format('%d_%s_published', level, type)] = orgUnit.published;
        record[util.format('%d_%s_parentId', level, type)] = orgUnit.ParentId;

        var hasChildrenOrSeries = (!_.isEmpty(orgUnit.children) || !_.isEmpty(orgUnit.series));
        if (!hasChildrenOrSeries) {
            records.push(record);
        } else {
            _.each(orgUnit.children, function(child) {
                var copyRecord = _.clone(record);
                visitOrgUnit(child, copyRecord, level + 1);
            });

            _.each(orgUnit.series, function(series) {
                var copyRecord = _.clone(record);
                visitSeries(series, copyRecord);
            });
        }

        // TODO: Support directly associated events
    };

    var visitSeries = function(series, record) {
        record['series_id'] = series.id;
        record['series_externalId'] = series.externalId;
        record['series_displayName'] = series.displayName;
        record['series_description'] = series.description;

        if (_.isEmpty(series.events)) {
            records.push(record);
        } else {
            _.each(series.events, function(event) {
                var copyRecord = _.clone(record);
                visitEvent(event, copyRecord);
            });
        }
    };

    var visitEvent = function(event, record) {
        record['event_id'] = event.id;
        record['event_externalId'] = event.externalId;
        record['event_displayName'] = event.displayName;
        record['event_description'] = event.description;
        record['event_notes'] = event.notes;
        record['event_location'] = event.location;
        record['event_start'] = moment(event.start).format();
        record['event_end'] = moment(event.end).format();
        record['event_type'] = event.type;

        if (_.isEmpty(event.organisers)) {
            records.push(record);
        } else {
            _.each(event.organisers, function(organiser) {
                var copyRecord = _.clone(record);
                if (_.isObject(organiser)) {
                    copyRecord['organiser_id'] = organiser.id;
                    copyRecord['organiser_shibbolethId'] = organiser.shibbolethId;
                    copyRecord['organiser_displayName'] = organiser.displayName;
                } else {
                    copyRecord['organiser_displayName'] = organiser;
                }

                records.push(copyRecord);
            });
        }
    };

    visitOrgUnit(exportedOrgUnit, {}, 0);
    return records;
};

/**
 * Export the organisational units, event series and events under an organisational unit to JSON
 *
 * @param  {Number}         rootId              The id of the root organisational unit in the tree of organisational units, event series and events
 * @param  {OrgUnit[]}      orgUnits            All the organisational units that are in the tree. Each organisational unit should have the event series and events that are under it available on its object
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {String}         callback.data       The exported organisational units, event series and events as a JSON tree
 * @api private
 */
var _exportOrgUnitJSON = function(rootId, orgUnits, callback) {
    var exportOrgUnit = function(orgUnit) {
        // Get the children of this organisational unit so we can export those
        var children = _.filter(orgUnits, function(potentialChildOrgUnit) {
            return (potentialChildOrgUnit.ParentId === orgUnit.id);
        });

        return {
            'id': orgUnit.id,
            'externalId': orgUnit.externalId,
            'displayName': orgUnit.displayName,
            'description': orgUnit.description,
            'published': orgUnit.published,
            'metadata': orgUnit.metadata,
            'type': orgUnit.type,
            'ParentId': orgUnit.ParentId,
            '_type': 'orgUnit',
            'children': _.map(children, exportOrgUnit),
            'series': _.map(orgUnit.Series, _exportSeries.bind(null, orgUnit))
        };
    };

    var _exportSeries = function(orgUnit, series) {
        var borrowedFrom = null;
        if (series.OrgUnits.length > 1) {
            series.OrgUnits = _.sortBy(series.OrgUnits, function(orgUnit) {
                return orgUnit.OrgUnitsSeries.createdAt.getTime();
            });
            if (series.OrgUnits[0].id !== orgUnit.id) {
                borrowedFrom = series.OrgUnits[0];
            }
        }

        return {
            'id': series.id,
            'externalId': series.externalId,
            'displayName': series.displayName,
            'description': series.description,
            'metadata': series.metadata,
            '_type': 'series',
            'borrowedFrom': borrowedFrom,
            'events': _.map(series.Events, exportEvent)
        };
    };

    var exportEvent = function(event) {
        // Stringify the event instance so we have access to the `organisers` property
        event = event.toJSON();

        return {
            'id': event.id,
            'externalId': event.externalId,
            'displayName': event.displayName,
            'description': event.description,
            'notes': event.notes,
            'location': event.location,
            'start': event.start,
            'end': event.end,
            'type': event.type,
            '_type': 'event',
            'organisers': _.map(event.organisers, function(organiser) {
                var exportedOrganiser = {
                    'type': 'organiser'
                };
                if (_.isString(organiser)) {
                    exportedOrganiser.displayName = organiser;
                } else {
                    exportedOrganiser.id = organiser.id;
                    exportedOrganiser.shibbolethId = organiser.shibbolethId;
                    exportedOrganiser.displayName = organiser.displayName;
                }
                return exportedOrganiser;
            })
        };
    };

    // Find the root organisational unit
    var rootOrgUnit = _.find(orgUnits, function(orgUnit) {
        return (orgUnit.id === rootId);
    });

    // Build the tree
    var tree = exportOrgUnit(rootOrgUnit);

    return callback(null, tree);
};

/* Import */

/**
 * Import a set of given organisational units, event series and events into an organisational unit
 *
 * @param  {Number}             appId               The id of the application in which a tree will be imported
 * @param  {MergedTreeData}     mergedTreeData      The merged tree data that contains the tree to import and the data to delete
 * @param  {Function}           callback            Standard callback function
 * @param  {Object}             callback.err        An error object, if any
 */
var importTree = module.exports.importTree = function(appId, mergedTreeData, callback) {
    DB.getSequelize().transaction().complete(function(err, transaction) {
        if (err) {
            return callback(err);
        }

        // Import the tree
        // TODO: transaction for actual import logic
        _importOrgUnit(appId, mergedTreeData.tree, null, function(err) {
            if (err) {
                return _transactionRollback(transaction, err, err.msg, callback);
            }

            // Remove data
            var orgUnitIdsToDelete = _.pluck(mergedTreeData.deletedOrgUnits, 'id');
            DB.OrgUnit.destroy({
                'where': {
                    'id': orgUnitIdsToDelete
                },
                'transaction': transaction
            }).complete(function(err) {
                if (err) {
                    return _transactionRollback(transaction, err, 'Failed to delete organisational units through an import', callback);
                }

                var seriesIdsToDelete = _.pluck(mergedTreeData.deletedSeries, 'id');
                DB.Serie.destroy({
                    'where': {
                        'id': seriesIdsToDelete
                    },
                    'transaction': transaction
                }).complete(function(err) {
                    if (err) {
                        return _transactionRollback(transaction, err, 'Failed to delete series through an import', callback);
                    }

                    var eventIdsToDelete = _.pluck(mergedTreeData.deletedEvents, 'id');
                    DB.Event.destroy({
                        'where': {
                            'id': eventIdsToDelete
                        },
                        'transaction': transaction
                    }).complete(function(err) {
                        if (err) {
                            return _transactionRollback(transaction, err, 'Failed to delete events through an import', callback);
                        }

                        // Commit the transaction
                        transaction.commit().complete(callback);
                    });
                });
            });
        });
    });
};

/**
 * Roll-back a transaction. Once the transaction has been rolled back the given callback will be
 * invoked with the original `err` object
 *
 * @param  {Transaction}    transaction         The transaction to roll back
 * @param  {Object}         err                 The error object that caused the transaction to be rolled back
 * @param  {String}         msg                 The message to log for the given `err` and the message that should be passed back up to the callback function
 * @param  {Function}       callback            Invoked when the transaction has been rolled back
 * @param  {Object}         callback.err        A 500 error with the given `msg` as its error message
 * @api private
 */
var _transactionRollback = function(transaction, err, msg, callback) {
    // Log an error indicating something caused the transaction to be rolled back
    log().error({'err': err}, msg);

    // Roll back the actual transaction
    transaction.rollback().complete(function(rollbackErr) {
        // There isn't much we can do here other than log the error
        if (rollbackErr) {
            log().error({'err': rollbackErr}, 'Failed to roll back an import');
        }

        return callback({'code': 500, 'msg': msg});
    });
};

/**
 * Import an organisational unit
 *
 * @param  {Number}     appId           The id of the application in which a tree will be imported
 * @param  {Object}     orgUnit         The organisational unit to create
 * @param  {OrgUnit}    [parent]        The parent under which the organisational unit should be created
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importOrgUnit = function(appId, orgUnit, parent, callback) {
    _updateOrCreateOrgUnit(appId, orgUnit, parent, function(err, createdOrgUnit) {
        if (err) {
            log().error({'err': err, 'externalId': orgUnit.externalId}, 'Failed to import organisational unit');
            return callback(err);
        }

        // Import the organisational unit's child organisational units (if any)
        _importOrgUnitChildren(appId, orgUnit.children, createdOrgUnit, function(err) {
            if (err) {
                return callback(err);
            }

            // Import the series under this organisational unit
            _importOrgUnitSeries(appId, orgUnit.series, createdOrgUnit, function(err) {
                if (err) {
                    return callback(err);
                }

                // TODO: Import events directly associated to organisational units
                return callback();
            });
        });
    });
};

/**
 * Update or create an organisational unit
 *
 * @param  {Number}     appId                       The id of the application in which the organisational unit should be created
 * @param  {Object}     orgUnitToImport             The organisational unit to import
 * @param  {Object}     parent                      The parent organisational unit to which the organisational unit belongs
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Event}      callback.persistedOrgUnit   The persisted organisational unit
 * @api private
 */
var _updateOrCreateOrgUnit = function(appId, orgUnitToImport, parent, callback) {
    if (orgUnitToImport.id) {
        // Update the organisational unit
        getOrgUnit(orgUnitToImport.id, false, function(err, persistedOrgUnit) {
            if (err) {
                return callback(err);
            }

            var update = {
                'displayName': orgUnitToImport.displayName,
                'description': orgUnitToImport.description,
                'type': orgUnitToImport.type,
                'metadata': orgUnitToImport.metadata,
                'published': orgUnitToImport.published
            };
            return updateOrgUnit(persistedOrgUnit, update, callback);
        });
    } else {
        // Create the organisational unit
        var opts = {
            'description': orgUnitToImport.description,
            'externalId': orgUnitToImport.externalId,
            'metadata': orgUnitToImport.metadata,
            'published': orgUnitToImport.published,
            'parentId': parent.id
        };

        // TODO: Refactor this check out of the DAO
        _getOrCreateGroup(appId, orgUnitToImport.type, parent, function(err, groupId) {
            if (err) {
                return callback(err);
            }

            return createOrgUnit(appId, orgUnitToImport.displayName, orgUnitToImport.type, groupId, opts, callback);
        });
    }
};

/**
 * Get or create a group depending on the given type
 * TODO: Refactor this out of the DAO
 *
 * @param  {Number}     appId               The id of the application in which the group should be created
 * @param  {String}     type                The type for which to get or create a group
 * @param  {OrgUnit}    parent              The parent to whose group can be default if no group should be created
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Number}     callback.groupId    The id of the group that was retrieved or created
 * @api private
 */
var _getOrCreateGroup = function(appId, type, parent, callback) {
    if (type === 'module') {
        return callback(null, parent.GroupId);
    }

    GroupsDAO.createGroup(appId, [], function(err, group) {
        if (err) {
            return callback(err);
        }

        return callback(null, group.id);
    });
};

/**
 * Import the child organisational units of an organisational unit
 *
 * @param  {Number}     appId           The id of the application in which any child organisational units should be imported
 * @param  {Object[]}   children        The child organisational units to import
 * @param  {OrgUnit}    parent          The organisational unit under which the child organisational units should be imported
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importOrgUnitChildren = function(appId, children, parent, callback) {
    if (_.isEmpty(children)) {
        return callback();
    }

    var child = children.pop();
    _importOrgUnit(appId, child, parent, function(err) {
        if (err) {
            return callback(err);
        }

        return _importOrgUnitChildren(appId, children, parent, callback);
    });
};

/**
 * Import the series in an organisational unit
 *
 * @param  {Number}     appId           The id of the application in which the series should be imported
 * @param  {Object[]}   series          The series to import
 * @param  {OrgUnit}    orgUnit         The organisational unit under which the series should be imported
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importOrgUnitSeries = function(appId, series, orgUnit, callback) {
    if (_.isEmpty(series)) {
        return callback();
    }

    var seriesToImport = series.pop();
    _importSeries(appId, seriesToImport, orgUnit, function(err) {
        if (err) {
            return callback(err);
        }

        return _importOrgUnitSeries(appId, series, orgUnit, callback);
    });
};

/**
 * Import a series
 *
 * @param  {Number}     appId           The id of the application in which the series should be imported
 * @param  {Object}     series          The series to import
 * @param  {OrgUnit}    orgUnit         The organisational unit under which the series should be imported
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importSeries = function(appId, series, orgUnit, callback) {
    _updateOrCreateSeries(appId, series, orgUnit, function(err, persistedSeries) {
        if (err) {
            log().error({'err': err, 'externalId': series.externalId}, 'Failed to get or create series');
            return callback(err);
        }

        // Add the series to the organisational unit. If the series is already part of the organisational
        // unit, this shouldn't cause a duplicate or trigger an error
        addOrgUnitSeries(orgUnit, persistedSeries, function(err) {
            if (err) {
                log().error({'err': err, 'externalId': series.externalId}, 'Failed to add series to organisational unit');
                return callback(err);
            }

            // Import the events under this series
            return _importSeriesEvents(appId, series.events, persistedSeries, callback);
        });
    });
};

/**
 * Update or create a series
 *
 * @param  {Number}     appId                       The id of the application in which the series should be imported
 * @param  {Object}     seriesToImport              The series to import
 * @param  {Object}     orgUnit                     The organisational unit to which the series belongs
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Event}      callback.persistedSeries    The persisted series
 * @api private
 */
var _updateOrCreateSeries = function(appId, seriesToImport, orgUnit, callback) {
    seriesToImport.AppId = orgUnit.AppId;
    if (seriesToImport.id) {
        // Update the series
        SeriesDAO.getSerie(seriesToImport.id, false, function(err, persistedSeries) {
            if (err) {
                return callback(err);
            }

            var update = _.pick(seriesToImport, ['displayName', 'description', 'metadata']);
            return SeriesDAO.updateSerie(persistedSeries, update, callback);
        });
    } else {
        // Create the series
        return SeriesDAO.createSeries(appId, seriesToImport.displayName, seriesToImport.description, orgUnit.GroupId, seriesToImport.externalId, seriesToImport.metadata, callback);
    }
};

/**
 * Import the events in a series
 *
 * @param  {Number}     appId           The id of the application in which the events should be imported
 * @param  {Object[]}   events          The events to import
 * @param  {Serie}      series          The series under which the events should be imported
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importSeriesEvents = function(appId, events, series, callback) {
    if (_.isEmpty(events)) {
        return callback();
    }

    var event = events.pop();
    _importEvent(appId, event, series, function(err) {
        if (err) {
            return callback(err);
        }

        return _importSeriesEvents(appId, events, series, callback);
    });
};

/**
 * Import an event
 *
 * @param  {Number}     appId           The id of the application in which the event should be imported
 * @param  {Object}     event           The event to import
 * @param  {Serie}      series          The series under which the event should be imported
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 * @api private
 */
var _importEvent = function(appId, event, series, callback) {
    // Update or create the event record
    _updateOrCreateEvent(appId, event, series, function(err, persistedEvent) {
        if (err) {
            return callback(err);
        }

        // Get the users who are linked through their shibboleth id (if any)
        var organiserExternalIds = _.chain(event.organisers)
            .pluck('shibbolethId')
            .compact()
            .value();
        UsersDAO.getUsersByShibbolethId(appId, organiserExternalIds, function(err, users) {
            if (err) {
                return callback(err);
            }

            // Map the user's id to `true`
            var userIdOrganisers = {};
            _.each(users, function(user) {
                userIdOrganisers[user.id] = true;
            });

            // Map the plain text organiser strings to `true`
            var plainTextOrganisers = {};
            _.each(event.organisers, function(organiser) {
                // Any organiser for which no shibbolethId was provided will be added as plain-text
                if (!organiser.shibbolethId) {
                    plainTextOrganisers[organiser.displayName] = true;

                // If a shibbolethId was provided, but it couldn't be found in the database we'll
                // add it as plain-text
                } else if (!_.find(users, {'shibbolethId': organiser.shibbolethId})) {
                    var name = organiser.displayName || organiser.shibbolethId;
                    plainTextOrganisers[name] = true;
                }
            });

            // Add the organisers. Note that this does not support removing an organiser
            return EventsDAO.updateEventOrganisers(persistedEvent, userIdOrganisers, plainTextOrganisers, callback);
        });
    });
};

/**
 * Update or create an event
 *
 * @param  {Number}     appId                       The id of the application in which the event should be created
 * @param  {Object}     eventToImport               The event to import
 * @param  {Object}     series                      The series to which the event belongs
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @param  {Event}      callback.persistedEvent     The persisted event
 * @api private
 */
var _updateOrCreateEvent = function(appId, eventToImport, series, callback) {
    var opts = {
        'description': eventToImport.description,
        'displayName': eventToImport.displayName,
        'end': eventToImport.end,
        'location': eventToImport.location,
        'notes': eventToImport.notes,
        'start': eventToImport.start,
        'type': eventToImport.type
    };
    if (eventToImport.id) {
        // Update the event
        EventsDAO.getEvent(eventToImport.id, function(err, persistedEvent) {
            if (err) {
                return callback(err);
            }

            return EventsDAO.updateEvent(persistedEvent, opts, callback);
        });
    } else {
        // Create the event
        opts.group = series.GroupId;
        opts.series = [series.id];
        opts.externalId = eventToImport.externalId;
        return EventsDAO.createEvent(appId, opts.displayName, eventToImport.start, eventToImport.end, opts, callback);
    }
};
